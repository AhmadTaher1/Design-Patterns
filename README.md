 Design Patterns 🏗️
This repository contains code examples for various design patterns in Java, along with explanations and best practices.  

📌 What Are Design Patterns?
Design patterns are reusable solutions to common software design problems. They follow **SOLID principles** and help make code more **scalable, maintainable, and flexible**.  

1️⃣ Creational Patterns (Object Creation):

These patterns focus on how objects are created to improve flexibility and reuse.
Singleton – Ensures a class has only one instance and provides a global access point.
Factory Method – Creates objects without specifying the exact class.
Abstract Factory – Creates families of related objects without specifying their concrete classes.
Builder – Constructs complex objects step by step.
Prototype – Creates new objects by copying an existing object instead of instantiating from scratch.


2️⃣ Structural Patterns (Class & Object Composition):

These patterns focus on how objects are structured and interact with each other.
Adapter (Wrapper) – Allows two incompatible interfaces to work together.
Bridge – Decouples abstraction from implementation, allowing them to develop independently.
Composite – Treats individual objects and groups of objects uniformly.
Decorator – Adds behavior dynamically to an object at runtime.
Facade – Provides a simplified interface to a larger, complex system.
Flyweight – Shares objects efficiently to reduce memory usage.
Proxy – Controls access to an object (e.g., for lazy loading, security, caching).



3️⃣ Behavioral Patterns (Object Interaction):

These patterns focus on how objects communicate and manage behavior.
Chain of Responsibility – Passes a request along a chain of handlers until one handles it.
Command – Encapsulates a request as an object (useful for undo/redo operations).
Interpreter – Implements a custom language syntax and grammar.
Iterator – Provides a way to traverse a collection without exposing its structure.
Mediator – Centralizes communication between objects to reduce direct dependencies.
Memento – Captures and restores an object’s previous state (useful for undo mechanisms).
Observer (Pub-Sub) – Establishes a dependency where multiple objects get updated automatically when one changes.
State – Changes an object’s behavior when its state changes.
Strategy – Defines a family of interchangeable algorithms and lets the client choose at runtime.
Template Method – Defines the skeleton of an algorithm and lets subclasses override parts.
Visitor – Allows adding new operations to existing object structures without modifying them.
