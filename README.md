 Design Patterns ğŸ—ï¸
This repository contains code examples for various design patterns in Java, along with explanations and best practices.  

ğŸ“Œ What Are Design Patterns?
Design patterns are reusable solutions to common software design problems. They follow **SOLID principles** and help make code more **scalable, maintainable, and flexible**.  

1ï¸âƒ£ Creational Patterns (Object Creation):

These patterns focus on how objects are created to improve flexibility and reuse.
Singleton â€“ Ensures a class has only one instance and provides a global access point.
Factory Method â€“ Creates objects without specifying the exact class.
Abstract Factory â€“ Creates families of related objects without specifying their concrete classes.
Builder â€“ Constructs complex objects step by step.
Prototype â€“ Creates new objects by copying an existing object instead of instantiating from scratch.


2ï¸âƒ£ Structural Patterns (Class & Object Composition):

These patterns focus on how objects are structured and interact with each other.
Adapter (Wrapper) â€“ Allows two incompatible interfaces to work together.
Bridge â€“ Decouples abstraction from implementation, allowing them to develop independently.
Composite â€“ Treats individual objects and groups of objects uniformly.
Decorator â€“ Adds behavior dynamically to an object at runtime.
Facade â€“ Provides a simplified interface to a larger, complex system.
Flyweight â€“ Shares objects efficiently to reduce memory usage.
Proxy â€“ Controls access to an object (e.g., for lazy loading, security, caching).



3ï¸âƒ£ Behavioral Patterns (Object Interaction):

These patterns focus on how objects communicate and manage behavior.
Chain of Responsibility â€“ Passes a request along a chain of handlers until one handles it.
Command â€“ Encapsulates a request as an object (useful for undo/redo operations).
Interpreter â€“ Implements a custom language syntax and grammar.
Iterator â€“ Provides a way to traverse a collection without exposing its structure.
Mediator â€“ Centralizes communication between objects to reduce direct dependencies.
Memento â€“ Captures and restores an objectâ€™s previous state (useful for undo mechanisms).
Observer (Pub-Sub) â€“ Establishes a dependency where multiple objects get updated automatically when one changes.
State â€“ Changes an objectâ€™s behavior when its state changes.
Strategy â€“ Defines a family of interchangeable algorithms and lets the client choose at runtime.
Template Method â€“ Defines the skeleton of an algorithm and lets subclasses override parts.
Visitor â€“ Allows adding new operations to existing object structures without modifying them.
